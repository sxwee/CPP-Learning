# 条款13：以对象管理资源

将对象放进对象内，便可**通过C++的析构函数自动调用机制来确保资源被释放**。

以对象管理资源的两个关键想法：

- 获得资源后立刻放进管理对象
- 管理对象运用析构函数确保资源被释放。

**请记住**：

- 为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放。
- 两个常被使用的RAII 类分别是`shared_ptr`和`auto_ptr`。前者通常是较佳选择，因为其copy行为比较直观。若选择`auto_ptr`，复制动作会使它指向`null`。

# 条款14：在资源管理类中小心coping行为

当一个RAII（Resource Acquisition Is Initialization）对象被复制，可以选择如下行为：

- 禁止复制
- 对底层资源使用“计数引用法”
- 复制底部资源
- 转移底部资源的拥有权

**请记住**：

- 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为。
- 普遍而常见的RAII class copying行为是：抑制copying，施行计数法。

# 条款15：在资源管理类中提供对原始资源的访问

`shared_ptr`和`auto_ptr`都提供一个`get`成员函数，用来执行显示转换，也就是它会返回智能指针内部的原始指针。

**请记住**：

- APIs往往要求访问原始资源，所以每一个RAII class应该提供一个“取得其所管理之资源”的办法。
- 对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。

# 条款16：成对使用`new`和`delete`时要采取相同形式

使用`new`时，会发生两件事，一是内存被分配出来（通过名为`operator new`的函数），二是针对此内存有一个（或更多）构造函数被调用。当使用`delete`时，也有两件事发生，一是会有一个（或更多）析构函数被调用，然后内存才被释放（通过名为`operator delete`的函数）。`delete`的最大问题是，即将被删除的内存之内，究竟存有多少对象，其决定了有多少个析构函数必须被调用起来。

**请记住**：

- 如果你在`new`表达式中使用`[]`，必须在相应的`delete`表达式中也是用`[]`。如果你在`new`表达式中不使用`[]`，一定不要在相应的`delete`表达式中使用`[]`。

# 条款17：以独立语句将newed对象置入智能指针

**请记住**：

- 以独立语句newed对象存储于智能指针内，如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。

