# 条款5: 了解C++默认编写并调用哪些函数

对于空类，C++会默认为其创建**copy构造函数、copy assignment操作符、析构函数和default构造函数**。

若定义了如下的空类:

```cpp
class Empty {};
```

就好像写下如下代码:

```cpp
class Empty
{
public:
	Empty() {} // 默认构造函数
	Empty(const Empty& rhs) {} // 拷贝构造函数
	~Empty() {} // 析构函数
	Empty& operator=(const Empty& rhs) {} // 拷贝赋值运算符

};
```

注意，若类内存在`reference`成员，则C++不会重载默认的赋值运算符，示例如下。

```cpp
class Empty
{
public:
	Empty(string &name):name(name) {} // 默认构造函数
private:
	string& name;
};


int main()
{
	string na1 = "Tom", na2 = "Jack";
	Empty e1(na1);
	Empty e2(na2);
	// 无法引用 函数 "Empty::operator=(const Empty &)" (已隐式声明) --它是已删除的函数
	e2 = e1;
	return 0;
}
```

# 条款6: 若不想使用编译器自动生成的函数，就该明确拒绝

为驳回编译器自动提供的功能，可将相应的成员函数声明为`private`并且不予实现。

# 条款7: 为多态基类声明为`virtual`析构函数

当派生类对象经由一个基类指针被删除时，而基类的拥有一个`non-virtual`的析构函数，其结果未有定义——实际执行时通常发生的是对象的`derived`成分没被销毁，这样可能会造成资源泄露。

欲实现出`virtual`函数，对象必须携带某些信息，主要用来在运行期决定哪个`virtual`函数该被调用，这份信息通常是由一个**虚函数表指针vptr (virtual table pointer)**指出。vptr指向一个由函数指针构成的数组，称为**虚函数表vtbl（virtual table）**，每个带有`virtual`函数的类都有一个相应的虚函数表。

当对象调用某个`virtual`函数，**实际被调用的函数取决于该对象的vptr所指向的那个vtbl**——编译器在其中寻找适当的函数指针。

**请记住**：

- 带多态性质的基类应该声明一个`virtual`析构函数，如果类带有任何`virtual`函数，它就应该拥有一个`virtual`析构函数。
- 当类的设计目的不是作为基类，或不是为了具备多态性，就不该声明为`virtual`析构函数。

# 条款8: 别让异常逃离析构函数

C++不喜欢析构函数吐出异常。析构函数吐出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险。

**请记住**：

- 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后**吞下它们（不传播）或结束程序**。
- 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。

# 条款9: 绝不在构造函数和析构过程中调用`virtual`函数

**请记住**：

- 在构造和析构期间不要调用`virtual`函数，因为这类调用从不下降至派生类（比起当前执行构造函数和析构函数的那层）。

# 条款10: 令`operator=`返回一个`reference to *this`

**请记住**：

- 令赋值操作符返回一个`reference to *this`，因为其被所有内置类型或标准程序库提供的类型或即将提供的类型共同遵守。

# 条款11: 在`operator=`中处理自我赋值

在赋值操作符函数中，需要添加一个证同测试以避免自我赋值。

```cpp
Widget& Wedget::operator=(const Widget& rhs)
{
	if (this == &rhs)
		return *this;
	delete _Post_bytecap_;
	pb = new Bitmap(*rhs.bp);
	return *this;
}
```

**请记住**：

- 确保当对象自我赋值时`operator=`有良好的行为。其中技术包括比较“来源对象”和“目标对象的地址”，精心周到的语句顺序以及copy-and-swap。
- 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。

# 条款12：复制对象时勿忘其每一个成分

复制每一个成分指的是：(1)复制所有的local成员变量，(2)调用所有base classes内地适当copying函数。

**请记住**：

- Coping函数应确保复制"对象内的所有成员变量"及“所有base class成分”。
- 不要尝试以某个copying函数实现另一个copying函数，应当将共同机能放进第三个函数中，并由两个copying函数共同调用。

