# 条款18：让接口容易被正确使用，不易被误用

**请记住**：

- 好的接口实现很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质。
- “促进正确使用”的办法是包括接口的一致性，以及与内置类型的行为兼容。
- “阻止误用”的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。
- `shared_ptr`支持定制型删除器，这可防范DLL问题，可被用来自动解除互斥锁。

# 条款19：设计`class`犹如设计`type`

**请记住**：

- `Class`的设计就是type的设计。在定义一个新type之前，请确定你已经考虑过本条款覆盖的所有讨论主题。

# 条款20：宁以pass-by-reference-to-const替换pass-by-value

缺省情况下，C++以by value方式传递对象至函数，即**函数参数都是以实际参数的副本为初值，而调用端所获得的亦是函数返回值的一般副本**。这些副本系由对象的copy构造函数产出，这可能使得pass-by-value称为昂贵的操作。

使用pass-by-reference-to-const则效率要高得多，但其并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言pass-by-value往往比较合适。

# 条款21：必须返回对象时，别妄想返回其reference

**请记住**：

- 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能通知需要多个这样的对象。

# 条款22：将成员变量声明为private

将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。

**请记住**：

- 切记将成员变量声明为private，这可赋予客户访问数据的一致性、可细微划分访问控制、允诺约束条件获得保证，并提供class作者以充分的实现弹性。
- protected并不比public更具有封装性。

# 条款23：宁以non-member、non-friend替换member函数

**请记住**：

- 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性和机能扩充性。

# 条款24：若所有参数皆需类型转换，请为此采用non-member函数

**请记住**：

- 如果你需要为某个函数的所有参数（包括被`this`指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。

# 条款25：考虑写出一个不抛异常的swap函数

**请记住**：

- 当`std::swap`对你的类型效率不高时，提供一个swap函数，并确定这个函数不抛出异常。
- 如果你提供一个member swap，也该提供一个non-member swap用来调用前者，对于class（而非templates），也请特化`std::swap`>
- 调用swap时应针对`std::swap`使用`using`声明，然后调用`swap`并且不带任何命名空间修饰符。
- 为“用户定义类型“进行std templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。

